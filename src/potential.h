
namespace sirius {

// generated by the following Mathematica expression: 
//     Do[Print[Table[CForm[N[ Gamma[5/2+l+n]/ Gamma[3/2+l],20]],{n,0,10}],","],{l,0,30}]
const double gamma_factors[31][11] = {
{1.5,3.75,13.125,59.0625,324.84375,2111.484375,15836.1328125,134607.12890625,1.278767724609375e6,1.34270611083984375e7,1.5441120274658203125e8},
{2.5,8.75,39.375,216.5625,1407.65625,10557.421875,89738.0859375,852511.81640625,8.951374072265625e6,1.029408018310546875e8,1.2867600228881835938e9},
{3.5,15.75,86.625,563.0625,4222.96875,35895.234375,341004.7265625,3.58054962890625e6,4.1176320732421875e7,5.147040091552734375e8,6.9485041235961914062e9},
{4.5,24.75,160.875,1206.5625,10255.78125,97429.921875,1.0230141796875e6,1.176466306640625e7,1.47058288330078125e8,1.9852868924560546875e9,2.8786659940612792969e10},
{5.5,35.75,268.125,2279.0625,21651.09375,227336.484375,2.6143695703125e6,3.267961962890625e7,4.41174864990234375e8,6.3970355423583984375e9,9.9154050906555175781e10},
{6.5,48.75,414.375,3936.5625,41333.90625,475339.921875,5.9417490234375e6,8.021361181640625e7,1.163097371337890625e9,1.8028009255737304687e10,2.9746215271966552734e11},
{7.5,63.75,605.625,6359.0625,73129.21875,914115.234375,1.23405556640625e7,1.7893805712890625e8,2.773539885498046875e9,4.5763408110717773438e10,8.0085964193756103516e11},
{8.5,80.75,847.875,9750.5625,121882.03125,1.645407421875e6,2.38584076171875e7,3.6980531806640625e8,6.101787748095703125e9,1.0678128559167480469e11,1.9754537834459838867e12},
{9.5,99.75,1147.125,14339.0625,193577.34375,2.806871484375e6,4.35065080078125e7,7.1785738212890625e8,1.2562504187255859375e10,2.3240632746423339844e11,4.5319233855525512695e12},
{10.5,120.75,1509.375,20376.5625,295460.15625,4.579632421875e6,7.55639349609375e7,1.32236886181640625e9,2.4463823943603515625e10,4.7704456690026855469e11,9.7794136214555053711e12},
{11.5,143.75,1940.625,28139.0625,436155.46875,7.196565234375e6,1.259398916015625e8,2.32988799462890625e9,4.5432815895263671875e10,9.3137272585290527344e11,2.0024513605837463379e13},
{12.5,168.75,2446.875,37926.5625,625788.28125,1.0951294921875e7,2.025989560546875e8,3.95067964306640625e9,8.0988932682861328125e10,1.7412620526815185547e12,3.917839618533416748e13},
{13.5,195.75,3034.125,50063.0625,876103.59375,1.6207916484375e7,3.160543714453125e8,6.47911461462890625e9,1.3930096421452148438e11,3.1342716948267333984e12,7.3655384828428234863e13},
{14.5,224.75,3708.375,64896.5625,1.20058640625e6,2.3411434921875e7,4.799344158984375e8,1.031858994181640625e10,2.3216827369086914063e11,5.4559544317354248047e12,1.3367088357751790771e14},
{15.5,255.75,4475.625,82799.0625,1.61458171875e6,3.3098925234375e7,7.116268925390625e8,1.601160508212890625e10,3.7627271943002929687e11,9.2186816260357177734e12,2.3507638146391080322e14},
{16.5,288.75,5341.875,104166.5625,2.13541453125e6,4.5911412421875e7,1.0330067794921875e9,2.427565931806640625e10,5.9475365329262695312e11,1.5166218158961987305e13,4.0190478121249266357e14},
{17.5,323.75,6313.125,129419.0625,2.78250984375e6,6.2606471484375e7,1.4712520798828125e9,3.604567595712890625e10,9.1916473690678710938e11,2.4357865528029858398e13,6.6984130202082110596e14},
{18.5,360.75,7395.375,159000.5625,3.57751265625e6,8.4071547421875e7,2.0597529118359375e9,5.252369925181640625e10,1.3918780301731347656e12,3.8276645829761206055e13,1.0908844061481943726e15},
{19.5,399.75,8594.625,193379.0625,4.54440796875e6,1.11337995234375e8,2.8391188784765625e9,7.523665027962890625e10,2.0690078826897949219e12,5.8966724656659155273e13,1.7395183773714450806e15},
{20.5,440.75,9916.875,233046.5625,5.70964078125e6,1.45595839921875e8,3.8582897579296875e9,1.0610296834306640625e11,3.0239345977773925781e12,8.9206070634433081055e13,2.7207851543502089722e15},
{21.5,483.75,11368.125,278519.0625,7.10223609375e6,1.88209256484375e8,5.1757545533203125e9,1.4750900476962890625e11,4.3515156407040527344e12,1.327212270414736084e14,4.1807186518064186646e15},
{22.5,528.75,12954.375,330336.5625,8.75391890625e6,2.40732769921875e8,6.8608839427734375e9,2.0239607631181640625e11,6.1730803275104003906e12,1.944520303165776123e14,6.3196909852887723999e15},
{23.5,575.75,14681.625,389063.0625,1.069923421875e7,3.04928175234375e8,8.9953811694140625e9,2.7435912566712890625e11,8.6423124585145605469e12,2.8087515490172321777e14,9.4093176892077277954e15},
{24.5,624.75,16555.875,455286.5625,1.297566703125e7,3.82782177421875e8,1.16748564113671875e10,3.6775797695806640625e11,1.1952134251137158203e13,4.003964974130947998e14,1.3813679160751770593e16},
{25.5,675.75,18583.125,529619.0625,1.562376234375e7,4.76524751484375e8,1.50105296717578125e10,4.8784221433212890625e11,1.6342714180126318359e13,5.638236392143579834e14,2.0015739192109708411e16},
{26.5,728.75,20769.375,612696.5625,1.868724515625e7,5.88648222421875e8,1.91310672287109375e10,6.4089075216181640625e11,2.2110730949582666016e13,7.8493094871018464355e14,2.864997962792173949e16},
{27.5,783.75,23120.625,705179.0625,2.221314046875e7,7.21927065234375e8,2.41845566853515625e10,8.3436720564462890625e11,2.9620035800384326172e13,1.0811313067140279053e15,4.0542424001776046448e16},
{28.5,840.75,25642.875,807750.5625,2.625189328125e7,8.79438424921875e8,3.03406256598046875e10,1.0770922109230664062e12,3.9313865698691923828e13,1.4742699637009471436e15,5.6759393602486465027e16},
{29.5,899.75,28342.125,921119.0625,3.085748859375e7,1.064583356484375e9,3.77927091551953125e10,1.3794338841646289062e12,5.1728770656173583984e13,1.9915576702626829834e15,7.8666527975375977844e16},
{30.5,960.75,31224.375,1.0460165625e6,3.608757140625e7,1.281108784921875e9,4.67604706496484375e10,1.7535176493618164062e12,6.7510429500429931641e13,2.6666619652669822998e15,1.0799980959331278314e17},
{31.5,1023.75,34295.625,1.1831990625e6,4.200356671875e7,1.533130185234375e9,5.74923819462890625e10,2.2134567049321289062e12,8.7431539844819091797e13,3.5409773637151732178e15,1.4695056059417968854e17}};

/// Generate effective potential from charge density and magnetization
class Potential 
{
    private:
        
        Global& parameters_;

        int allocate_f_;
        
        PeriodicFunction<double>* effective_potential_;
        
        PeriodicFunction<double>* effective_magnetic_field_[3];
 
        mdarray<double, 3> sbessel_mom_;

        mdarray<double, 3> sbessel_mt_;
        
        SHT sht_;

        int pseudo_density_order;

        std::vector<complex16> zil_;
        
        std::vector<complex16> zilm_;

        mdarray<int, 1> l_by_lm_;

        /// Compute MT part of the potential and MT multipole moments
        void poisson_vmt(mdarray<complex16, 3>& rho_ylm, PeriodicFunction<double>* vh, mdarray<complex16, 2>& qmt)
        {
            Timer t("sirius::Potential::poisson:vmt");

            qmt.zero();
            
            for (int ialoc = 0; ialoc < parameters_.spl_num_atoms().local_size(); ialoc++)
            {
                int ia = parameters_.spl_num_atoms(ialoc);

                double R = parameters_.atom(ia)->type()->mt_radius();
                int nmtp = parameters_.atom(ia)->num_mt_points();
               
                #pragma omp parallel default(shared)
                {
                    std::vector<complex16> g1;
                    std::vector<complex16> g2;
   
                    Spline<complex16> rholm(nmtp, parameters_.atom(ia)->type()->radial_grid());

                    #pragma omp for
                    for (int lm = 0; lm < parameters_.lmmax_rho(); lm++)
                    {
                        int l = l_by_lm_(lm);

                        for (int ir = 0; ir < nmtp; ir++) rholm[ir] = rho_ylm(lm, ir, ialoc);
                        rholm.interpolate();

                        // save multipole moment
                        qmt(lm, ia) = rholm.integrate(g1, l + 2);
                        
                        if (lm < parameters_.lmmax_pot())
                        {
                            rholm.integrate(g2, 1 - l);
                            
                            double d1 = 1.0 / pow(R, 2 * l + 1); 
                            double d2 = 1.0 / double(2 * l + 1); 
                            for (int ir = 0; ir < nmtp; ir++)
                            {
                                double r = parameters_.atom(ia)->type()->radial_grid(ir);

                                complex16 vlm = (1.0 - pow(r / R, 2 * l + 1)) * g1[ir] / pow(r, l + 1) +
                                                (g2[nmtp - 1] - g2[ir]) * pow(r, l) - 
                                                (g1[nmtp - 1] - g1[ir]) * pow(r, l) * d1;

                                vh->f_ylm(lm, ir, ialoc) = fourpi * vlm * d2;
                            }
                        }
                    }
                }
                
                // nuclear potential
                for (int ir = 0; ir < nmtp; ir++)
                {
                    double r = parameters_.atom(ia)->type()->radial_grid(ir);
                    vh->f_ylm(0, ir, ialoc) -= fourpi * y00 * parameters_.atom(ia)->type()->zn() * (1.0 / r - 1.0 / R);
                }

                // nuclear multipole moment
                qmt(0, ia) -= parameters_.atom(ia)->type()->zn() * y00;
            }

            Platform::allreduce(&qmt(0, 0), (int)qmt.size());
        }


        /// Compute multipole momenst of the interstitial charge density

        /** Also, compute the MT boundary condition 
            
        */
        void poisson_sum_G(complex16* fpw, mdarray<double, 3>& fl, mdarray<complex16, 2>& flm)
        {
            Timer t("sirius::Potential::poisson_sum_G");
            
            flm.zero();

            mdarray<complex16, 2> zm1(parameters_.spl_num_gvec().local_size(), parameters_.lmmax_rho());

            #pragma omp parallel for default(shared)
            for (int lm = 0; lm < parameters_.lmmax_rho(); lm++)
            {
                for (int igloc = 0; igloc < parameters_.spl_num_gvec().local_size(); igloc++)
                    zm1(igloc, lm) = parameters_.gvec_ylm(lm, igloc) * conj(fpw[parameters_.spl_num_gvec(igloc)] * zilm_[lm]);
            }

            mdarray<complex16, 2> zm2(parameters_.spl_num_gvec().local_size(), parameters_.num_atoms());

            for (int l = 0; l <= parameters_.lmax_rho(); l++)
            {
                #pragma omp parallel for default(shared)
                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                {
                    int iat = parameters_.atom_type_index_by_id(parameters_.atom(ia)->type_id());
                    for (int igloc = 0; igloc < parameters_.spl_num_gvec().local_size(); igloc++)
                    {
                        zm2(igloc, ia) = fourpi * parameters_.gvec_phase_factor<local>(igloc, ia) *  
                                         fl(l, iat, parameters_.gvec_shell<local>(igloc));
                    }
                }

                blas<cpu>::gemm(2, 0, 2 * l + 1, parameters_.num_atoms(), parameters_.spl_num_gvec().local_size(), 
                                &zm1(0, Utils::lm_by_l_m(l, -l)), zm1.ld(), &zm2(0, 0), zm2.ld(), 
                                &flm(Utils::lm_by_l_m(l, -l), 0), parameters_.lmmax_rho());
            }
            
            Platform::allreduce(&flm(0, 0), (int)flm.size());
        }

        /// Compute contribution from the pseudocharge to the plane-wave expansion
        void poisson_pw(mdarray<complex16, 2>& qmt, mdarray<complex16, 2>& qit, complex16* pseudo_pw)
        {
            Timer t("sirius::Potential::poisson_pw");
            memset(pseudo_pw, 0, parameters_.num_gvec() * sizeof(complex16));
            
            // 
            // The following term is added to the plane-wave coefficients of the charge density:
            // Integrate[SphericalBesselJ[l,a*x]*p[x,R]*x^2,{x,0,R},Assumptions->{l>=0,n>=0,R>0,a>0}] / 
            //   Integrate[p[x,R]*x^(2+l),{x,0,R},Assumptions->{h>=0,n>=0,R>0}]
            // i.e. contributon from pseudodensity to l-th channel of plane wave expansion multiplied by 
            // the difference bethween true and interstitial-in-the-mt multipole moments and divided by the 
            // moment of the pseudodensity
            
            // precompute R^(-l)
            mdarray<double, 2> Rl(parameters_.lmax_rho() + 1, parameters_.num_atom_types());
            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
            {
                for (int l = 0; l <= parameters_.lmax_rho(); l++)
                    Rl(l, iat) = pow(parameters_.atom_type(iat)->mt_radius(), -l);
            }

            #pragma omp parallel default(shared)
            {
                std::vector<complex16> pseudo_pw_pt(parameters_.spl_num_gvec().local_size(), complex16(0, 0));

                #pragma omp for
                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                {
                    int iat = parameters_.atom_type_index_by_id(parameters_.atom(ia)->type_id());

                    double R = parameters_.atom(ia)->type()->mt_radius();

                    // compute G-vector independent prefactor
                    std::vector<complex16> zp(parameters_.lmmax_rho());
                    for (int l = 0, lm = 0; l <= parameters_.lmax_rho(); l++)
                    {
                        for (int m = -l; m <= l; m++, lm++)
                        {
                            zp[lm] = (qmt(lm, ia) - qit(lm, ia)) * Rl(l, iat) * conj(zil_[l]) *
                                     gamma_factors[l][pseudo_density_order]; 
                        }
                    }

                    for (int igloc = 0; igloc < parameters_.spl_num_gvec().local_size(); igloc++)
                    {
                        int ig = parameters_.spl_num_gvec(igloc);
                        
                        double gR = parameters_.gvec_len(ig) * R;
                        
                        complex16 zt = fourpi * conj(parameters_.gvec_phase_factor<local>(igloc, ia)) / parameters_.omega();

                        // TODO: add to documentation
                        // (2^(1/2+n) Sqrt[\[Pi]] R^-l (a R)^(-(3/2)-n) BesselJ[3/2+l+n,a R] * 
                        //   Gamma[5/2+l+n])/Gamma[3/2+l] and BesselJ is expressed in terms of SphericalBesselJ
                        if (ig)
                        {
                            complex16 zt2(0, 0);
                            for (int l = 0, lm = 0; l <= parameters_.lmax_rho(); l++)
                            {
                                complex16 zt1(0, 0);
                                for (int m = -l; m <= l; m++, lm++)
                                    zt1 += parameters_.gvec_ylm(lm, igloc) * zp[lm];

                                zt2 += zt1 * sbessel_mt_(l + pseudo_density_order + 1, iat, parameters_.gvec_shell<global>(ig));
                            }

                            pseudo_pw_pt[igloc] += zt * zt2 * pow(2.0 / gR, pseudo_density_order + 1);
                        }
                        else // for |G|=0
                        {
                            pseudo_pw_pt[igloc] += zt * y00 * (qmt(0, ia) - qit(0, ia));
                        }
                    }
                }
                #pragma omp critical
                for (int igloc = 0; igloc < parameters_.spl_num_gvec().local_size(); igloc++) 
                    pseudo_pw[parameters_.spl_num_gvec(igloc)] += pseudo_pw_pt[igloc];
            }

            Platform::allreduce(&pseudo_pw[0], parameters_.num_gvec());
        }

        /// Poisson solver
        /** Plane wave expansion
            \f[
                e^{i{\bf g}{\bf r}}=4\pi e^{i{\bf g}{\bf r}_{\alpha}} \sum_{\ell m} i^\ell 
                    j_{\ell}(g|{\bf r}-{\bf r}_{\alpha}|)
                    Y_{\ell m}^{*}({\bf \hat g}) Y_{\ell m}(\widehat{{\bf r}-{\bf r}_{\alpha}})
            \f]

            Multipole moment:
            \f[
                q_{\ell m} = \int Y_{\ell m}^{*}(\hat {\bf r}) r^l \rho({\bf r}) d {\bf r}

            \f]

            Spherical Bessel function moments
            \f[
                \int_0^R j_{\ell}(a x)x^{2+\ell} dx = \frac{\sqrt{\frac{\pi }{2}} R^{\ell+\frac{3}{2}} 
                    J_{\ell+\frac{3}{2}}(a R)}{a^{3/2}}
            \f]
            for a = 0 the integral is \f$ \frac{R^3}{3} \delta_{\ell,0} \f$

            General solution to the Poisson equation with spherical boundary condition:
            \f[
                V({\bf x}) = \int \rho({\bf x'})G({\bf x},{\bf x'}) d{\bf x'} - \frac{1}{4 \pi} \int_{S} V({\bf x'}) 
                    \frac{\partial G}{\partial n'} d{\bf S'}
            \f]

            Green's function for a sphere
            \f[
                G({\bf x},{\bf x'}) = 4\pi \sum_{\ell m} \frac{Y_{\ell m}^{*}(\hat {\bf x'}) 
                    Y_{\ell m}(\hat {\bf x})}{2\ell + 1}
                    \frac{r_{<}^{\ell}}{r_{>}^{\ell+1}}\Biggl(1 - \Big( \frac{r_{>}}{R} \Big)^{2\ell + 1} \Biggr)
            \f]

            Pseudodensity radial functions:
            \f[
                p_{\ell}(r) = r^{\ell} \left(1-\frac{r^2}{R^2}\right)^n
            \f]
            where n is the order of pseudo density.

        */
        void poisson(PeriodicFunction<double>* rho, PeriodicFunction<double>* vh)
        {
            Timer t("sirius::Potential::poisson");
            
            // temporary Ylm components of charge density
            mdarray<complex16, 3> rho_ylm(parameters_.lmmax_rho(), parameters_.max_num_mt_points(), 
                                          parameters_.spl_num_atoms().local_size());

            // convert charge density to Ylm expansion
            for (int ialoc = 0; ialoc < parameters_.spl_num_atoms().local_size(); ialoc++)
            {
                int ia = parameters_.spl_num_atoms(ialoc);
                for (int ir = 0; ir < parameters_.atom(ia)->num_mt_points(); ir++)
                    sht_.convert_to_ylm(parameters_.lmax_rho(), &rho->f_rlm(0, ir, ia), &rho_ylm(0, ir, ialoc));
            }
            
            // true multipole moments
            mdarray<complex16, 2> qmt(parameters_.lmmax_rho(), parameters_.num_atoms());
            poisson_vmt(rho_ylm, vh, qmt);

            // compute multipoles of interstitial density in MT region
            mdarray<complex16, 2> qit(parameters_.lmmax_rho(), parameters_.num_atoms());
            poisson_sum_G(rho->f_pw(), sbessel_mom_, qit);
            
            // compute contribution from the pseudo-charge
            std::vector<complex16> pseudo_pw(parameters_.num_gvec());
            poisson_pw(qmt, qit, &pseudo_pw[0]);

            // add interstitial charge density; now pseudo_pw has the correct multipole moments in the muffin-tins
            for (int ig = 0; ig < parameters_.num_gvec(); ig++) pseudo_pw[ig] += rho->f_pw(ig); 
            
            if (check_pseudo_charge)
            {
                poisson_sum_G(&pseudo_pw[0], sbessel_mom_, qit);

                double d = 0.0;
                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                {
                    for (int lm = 0; lm < parameters_.lmmax_rho(); lm++) d += abs(qmt(lm, ia) - qit(lm, ia));
                }

                parameters_.rti().pseudo_charge_error = d;
            }
            else
            {
                parameters_.rti().pseudo_charge_error = 0.0;
            }
 
            // compute pw coefficients of Hartree potential
            pseudo_pw[0] = 0.0;
            vh->f_pw(0) = 0.0;
            for (int ig = 1; ig < parameters_.num_gvec(); ig++)
                vh->f_pw(ig) = pseudo_pw[ig] * fourpi / pow(parameters_.gvec_len(ig), 2);

            // compute V_lm at the MT boundary
            mdarray<complex16, 2> vmtlm(parameters_.lmmax_pot(), parameters_.num_atoms());
            poisson_sum_G(vh->f_pw(), sbessel_mt_, vmtlm);
            
            // add boundary condition and convert to Rlm
            Timer* t1 = new Timer("sirius::Potential::poisson:bc");
            mdarray<double, 2> rRl(parameters_.max_num_mt_points(), parameters_.lmax_pot() + 1);
            int type_id_prev = -1;

            for (int ialoc = 0; ialoc < parameters_.spl_num_atoms().local_size(); ialoc++)
            {
                int ia = parameters_.spl_num_atoms(ialoc);

                if (parameters_.atom(ia)->type_id() != type_id_prev)
                {
                    type_id_prev = parameters_.atom(ia)->type_id();
                
                    double R = parameters_.atom(ia)->type()->mt_radius();

                    #pragma omp parallel for default(shared)
                    for (int l = 0; l <= parameters_.lmax_pot(); l++)
                    {
                        for (int ir = 0; ir < parameters_.atom(ia)->num_mt_points(); ir++)
                            rRl(ir, l) = pow(parameters_.atom(ia)->type()->radial_grid(ir) / R, l);
                    }
                }

                #pragma omp parallel for default(shared)
                for (int lm = 0; lm < parameters_.lmmax_pot(); lm++)
                {
                    int l = l_by_lm_(lm);

                    for (int ir = 0; ir < parameters_.atom(ia)->num_mt_points(); ir++)
                        vh->f_ylm(lm, ir, ialoc) += vmtlm(lm, ia) * rRl(ir, l);
                }

                for (int ir = 0; ir < parameters_.atom(ia)->num_mt_points(); ir++)
                {
                    sht_.convert_to_rlm(parameters_.lmax_pot(), &vh->f_ylm(0, ir, ialoc), &vh->f_rlm(0, ir, ialoc));
                }
            }
            delete t1;
            
            // transform Hartree potential to real space
            parameters_.fft().input(parameters_.num_gvec(), parameters_.fft_index(), vh->f_pw());
            parameters_.fft().transform(1);
            parameters_.fft().output(vh->f_it());
        }

        void xc(PeriodicFunction<double>* rho, PeriodicFunction<double>* magnetization[3], 
                PeriodicFunction<double>* vxc, PeriodicFunction<double>* bxc[3], PeriodicFunction<double>* exc)
        {
            Timer t("sirius::Potential::xc");

            libxc_interface xci;
            
            mdarray<double, 2> rhotp(sht_.num_points(), parameters_.max_num_mt_points());
            mdarray<double, 2> vxctp(sht_.num_points(), parameters_.max_num_mt_points());
            mdarray<double, 2> exctp(sht_.num_points(), parameters_.max_num_mt_points());
            
            mdarray<double, 3> vecmagtp(sht_.num_points(), parameters_.max_num_mt_points(), parameters_.num_mag_dims());
            mdarray<double, 2> magtp(sht_.num_points(), parameters_.max_num_mt_points());
            mdarray<double, 3> vecbxctp(sht_.num_points(), parameters_.max_num_mt_points(), parameters_.num_mag_dims());
            mdarray<double, 2> bxctp(sht_.num_points(), parameters_.max_num_mt_points());

            Timer* t2 = new Timer("sirius::Potential::xc:mt");
            for (int ialoc = 0; ialoc < parameters_.spl_num_atoms().local_size(); ialoc++)
            {
                int ia = parameters_.spl_num_atoms(ialoc);
                int nmtp = parameters_.atom(ia)->num_mt_points();

                sht_.rlm_backward_transform(&rho->f_rlm(0, 0, ia), parameters_.lmmax_rho(), nmtp, &rhotp(0, 0));

                double rhomin = 0.0;
                for (int ir = 0; ir < nmtp; ir++)
                {
                    for (int itp = 0; itp < sht_.num_points(); itp++) rhomin = std::min(rhomin, rhotp(itp, ir));
                }

                if (rhomin < 0.0)
                {
                    std::stringstream s;
                    s << "Charge density for atom " << ia << " has negative values" << std::endl
                      << "most negatve value : " << rhomin << std::endl
                      << "current Rlm expansion of the charge density may be not sufficient, try to increase lmax_rho";
                    error(__FILE__, __LINE__, s);
                }

                if (parameters_.num_spins() == 2)
                {
                    for (int j = 0; j < parameters_.num_mag_dims(); j++)
                        sht_.rlm_backward_transform(&magnetization[j]->f_rlm(0, 0, ia), parameters_.lmmax_rho(), nmtp,
                                                    &vecmagtp(0, 0, j));
                    for (int ir = 0; ir < nmtp; ir++)
                    {
                        for (int itp = 0; itp < sht_.num_points(); itp++)
                        {
                            double t = 0.0;
                            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                                t += vecmagtp(itp, ir, j) * vecmagtp(itp, ir, j);
                            magtp(itp, ir) = sqrt(t);
                        }
                    }
                }
                
                if (parameters_.num_spins() == 1) 
                {
                    #pragma omp parallel for default(shared)
                    for (int ir = 0; ir < nmtp; ir++)
                    {
                        xci.getxc(sht_.num_points(), &rhotp(0, ir), &vxctp(0, ir), &exctp(0, ir));
                    }
                }
                else
                {
                    #pragma omp parallel for default(shared)
                    for (int ir = 0; ir < nmtp; ir++)
                    {
                        xci.getxc(sht_.num_points(), &rhotp(0, ir), &magtp(0, ir), &vxctp(0, ir), &bxctp(0, ir), 
                                  &exctp(0, ir));
                    }
                }

                sht_.rlm_forward_transform(&vxctp(0, 0), parameters_.lmmax_pot(), nmtp, &vxc->f_rlm(0, 0, ialoc));
                sht_.rlm_forward_transform(&exctp(0, 0), parameters_.lmmax_pot(), nmtp, &exc->f_rlm(0, 0, ialoc));

                if (parameters_.num_spins() == 2)
                {
                    vecbxctp.zero();
                    for (int ir = 0; ir < nmtp; ir++)
                    {
                        for (int itp = 0; itp < sht_.num_points(); itp++)
                        {
                            if (magtp(itp, ir) > 1e-8)
                            {
                                for (int j = 0; j < parameters_.num_mag_dims(); j++)
                                    vecbxctp(itp, ir, j) = bxctp(itp, ir) * vecmagtp(itp, ir, j) / magtp(itp, ir);
                            }
                            else
                            {
                                for (int j = 0; j < parameters_.num_mag_dims(); j++) vecbxctp(itp, ir, j) = 0.0;
                            }
                        }       
                    }
                    for (int j = 0; j < parameters_.num_mag_dims(); j++)
                    {
                        sht_.rlm_forward_transform(&vecbxctp(0, 0, j), parameters_.lmmax_pot(), nmtp,
                                                   &bxc[j]->f_rlm(0, 0, ialoc));
                    }
                }
            }
            delete t2;
          
            Timer* t3 = new Timer("sirius::Potential::xc:it");

            // TODO: this is unreadable and must be reimplemented
            // global offset
            int it_glob_idx = parameters_.spl_fft_size(0);
            int it_loc_size = parameters_.spl_fft_size().local_size();

            if (parameters_.num_spins() == 1)
            {
                xci.getxc(it_loc_size, &rho->f_it(it_glob_idx), vxc->f_it(), exc->f_it());
            }
            else
            {
                std::vector<double> magit(it_loc_size);
                std::vector<double> bxcit(it_loc_size);

                for (int irloc = 0; irloc < it_loc_size; irloc++)
                {
                    double t = 0.0;
                    for (int j = 0; j < parameters_.num_mag_dims(); j++)
                    {
                        t += magnetization[j]->f_it(parameters_.spl_fft_size(irloc)) *
                             magnetization[j]->f_it(parameters_.spl_fft_size(irloc));
                    }
                    magit[irloc] = sqrt(t);
                }
                xci.getxc(it_loc_size, &rho->f_it(it_glob_idx), &magit[0], vxc->f_it(), &bxcit[0], exc->f_it());
                
                for (int irloc = 0; irloc < it_loc_size; irloc++)
                {
                    if (magit[irloc] > 1e-8)
                    {
                        for (int j = 0; j < parameters_.num_mag_dims(); j++)
                        {
                            bxc[j]->f_it(irloc) = (bxcit[irloc] / magit[irloc]) * 
                                                  magnetization[j]->f_it(parameters_.spl_fft_size(irloc));
                        }
                    }
                    else
                    {
                        for (int j = 0; j < parameters_.num_mag_dims(); j++) bxc[j]->f_it(irloc) = 0.0;
                    }
                }
            }
            delete t3;
        }

    public:

        Potential(Global& parameters__, int allocate_f__ = pw_component) : 
            parameters_(parameters__), allocate_f_(allocate_f__), pseudo_density_order(10)
        {
            Timer t("sirius::Potential::Potential");
            
            int lmax = std::max(parameters_.lmax_rho(), parameters_.lmax_pot());
            sht_.set_lmax(lmax);

            // compute values of spherical Bessel functions at MT boundary
            sbessel_mt_.set_dimensions(lmax + pseudo_density_order + 2, parameters_.num_atom_types(), 
                                       parameters_.num_gvec_shells());
            sbessel_mt_.allocate();

            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
            {
                for (int igs = 0; igs < parameters_.num_gvec_shells(); igs++)
                {
                    gsl_sf_bessel_jl_array(lmax + pseudo_density_order + 1, 
                                           parameters_.gvec_shell_len(igs) * parameters_.atom_type(iat)->mt_radius(), 
                                           &sbessel_mt_(0, iat, igs));
                }
            }

            /* compute moments of spherical Bessel functions 
             
               Integrate[SphericalBesselJ[l,a*x]*x^(2+l),{x,0,R},Assumptions->{R>0,a>0,l>=0}]
               and use relation between Bessel and spherical Bessel functions: 
                 Subscript[j, n](z)=Sqrt[\[Pi]/2]/Sqrt[z]Subscript[J, n+1/2](z) 
            */
            sbessel_mom_.set_dimensions(parameters_.lmax_rho() + 1, parameters_.num_atom_types(), 
                                        parameters_.num_gvec_shells());
            sbessel_mom_.allocate();
            sbessel_mom_.zero();

            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
            {
                sbessel_mom_(0, iat, 0) = pow(parameters_.atom_type(iat)->mt_radius(), 3) / 3.0; // for |G|=0
                for (int igs = 1; igs < parameters_.num_gvec_shells(); igs++)
                {
                    for (int l = 0; l <= parameters_.lmax_rho(); l++)
                    {
                        sbessel_mom_(l, iat, igs) = pow(parameters_.atom_type(iat)->mt_radius(), 2 + l) * 
                                                    sbessel_mt_(l + 1, iat, igs) / parameters_.gvec_shell_len(igs);
                    }
                }
            }

            effective_potential_ = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
            effective_potential_->allocate(allocate_f_);

            for (int j = 0; j < parameters_.num_mag_dims(); j++)
            {
                effective_magnetic_field_[j] = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
                effective_magnetic_field_[j]->allocate(allocate_f_);
            }
            
            // precompute i^l
            zil_.resize(parameters_.lmax_rho() + 1);
            for (int l = 0; l <= parameters_.lmax_rho(); l++) zil_[l] = pow(complex16(0, 1), l);
            
            zilm_.resize(parameters_.lmmax_rho());
            for (int l = 0, lm = 0; l <= parameters_.lmax_rho(); l++)
            {
                for (int m = -l; m <= l; m++, lm++) zilm_[lm] = zil_[l];
            }

            l_by_lm_.set_dimensions(Utils::lmmax_by_lmax(lmax));
            l_by_lm_.allocate();
            for (int l = 0, lm = 0; l <= lmax; l++)
            {
                for (int m = -l; m <= l; m++, lm++) l_by_lm_(lm) = l;
            }
        }

        ~Potential()
        {
            delete effective_potential_; 
            for (int j = 0; j < parameters_.num_mag_dims(); j++) delete effective_magnetic_field_[j];
        }

        void set_effective_potential_ptr(double* veffmt, double* veffir)
        {
            effective_potential_->set_rlm_ptr(veffmt);
            effective_potential_->set_it_ptr(veffir);
        }
        
        void set_effective_magnetic_field_ptr(double* beffmt, double* beffir)
        {
            assert(parameters_.num_spins() == 2);

            // set temporary array wrapper
            mdarray<double,4> beffmt_tmp(beffmt, parameters_.lmmax_pot(), parameters_.max_num_mt_points(), 
                                         parameters_.num_atoms(), parameters_.num_mag_dims());
            mdarray<double,2> beffir_tmp(beffir, parameters_.fft().size(), parameters_.num_mag_dims());
            
            if (parameters_.num_mag_dims() == 1)
            {
                // z
                effective_magnetic_field_[0]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 0));
                effective_magnetic_field_[0]->set_it_ptr(&beffir_tmp(0, 0));
            }
            
            if (parameters_.num_mag_dims() == 3)
            {
                // z
                effective_magnetic_field_[0]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 2));
                effective_magnetic_field_[0]->set_it_ptr(&beffir_tmp(0, 2));
                // x
                effective_magnetic_field_[1]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 0));
                effective_magnetic_field_[1]->set_it_ptr(&beffir_tmp(0, 0));
                // y
                effective_magnetic_field_[2]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 1));
                effective_magnetic_field_[2]->set_it_ptr(&beffir_tmp(0, 1));
            }
        }
         
        /// Zero effective potential and magnetic field.
        void zero()
        {
            effective_potential_->zero();
            for (int j = 0; j < parameters_.num_mag_dims(); j++) effective_magnetic_field_[j]->zero();
        }

        /// Generate effective potential and magnetic field from charge density and magnetization.
        void generate_effective_potential(PeriodicFunction<double>* rho, PeriodicFunction<double>* magnetization[3])
        {
            Timer t("sirius::Potential::generate_effective_potential");
            
            // zero effective potential and magnetic field
            zero();

            // get plane-wave coefficients of the charge density
            parameters_.fft().input(rho->f_it());
            parameters_.fft().transform(-1);
            parameters_.fft().output(parameters_.num_gvec(), parameters_.fft_index(), rho->f_pw());
            
            // allocate Hartree potential
            PeriodicFunction<double>* vh = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
            vh->split(rlm_component | ylm_component);
            vh->allocate(rlm_component | ylm_component | pw_component | it_component);

            // solve Poisson equation
            poisson(rho, vh);

            // compute <rho | V_H>
            parameters_.rti().energy_vha = rho->inner(vh, rlm_component | it_component);

            double vh_mt_val;
            double vh_it_val;
            vh->inner(vh, it_component | rlm_component, vh_mt_val, vh_it_val);

            // compute Eenuc
            double enuc = 0.0;
            for (int ialoc = 0; ialoc < parameters_.spl_num_atoms().local_size(); ialoc++)
            {
                int ia = parameters_.spl_num_atoms(ialoc);
                int zn = parameters_.atom(ia)->type()->zn();
                double r0 = parameters_.atom(ia)->type()->radial_grid(0);
                // ==========================================================
                // compute energy of nucleus in the electrostatic potential 
                // generated by the total (electrons + nuclei) charge density;
                // diverging self-interaction term z*z/|r=0| is excluded
                // ==========================================================
                enuc -= 0.5 * zn * (vh->f_rlm(0, 0, ialoc) * y00 + zn / r0);
            }
            Platform::allreduce(&enuc, 1);

            parameters_.rti().energy_enuc = enuc;
            
            // add Hartree potential to the total potential
            effective_potential_->add(vh, rlm_component | it_component);

            delete vh;

            // allocate functions
            PeriodicFunction<double>* vxc = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
            vxc->split(rlm_component | it_component);
            vxc->allocate(rlm_component | it_component);

            PeriodicFunction<double>* exc = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());     
            exc->split(rlm_component | it_component);
            exc->allocate(rlm_component | it_component);
            
            PeriodicFunction<double>* bxc[3];
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
            {
                bxc[j] = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
                bxc[j]->split(rlm_component | it_component);
                bxc[j]->allocate(rlm_component | it_component);
            }

            xc(rho, magnetization, vxc, bxc, exc);
           
            effective_potential_->add(vxc, rlm_component | it_component);

            effective_potential_->sync(rlm_component | it_component);

            parameters_.rti().energy_veff = rho->inner(effective_potential_, rlm_component | it_component);
            parameters_.rti().energy_vxc = rho->inner(vxc, rlm_component | it_component);
            parameters_.rti().energy_exc = rho->inner(exc, rlm_component | it_component);

            double ebxc = 0.0;
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                ebxc += magnetization[j]->inner(bxc[j], rlm_component | it_component);
            parameters_.rti().energy_bxc = ebxc;

            delete vxc;

            for (int j = 0; j < parameters_.num_mag_dims(); j++)
            {
                effective_magnetic_field_[j]->add(bxc[j], rlm_component | it_component);
                effective_magnetic_field_[j]->sync(rlm_component | it_component);
                delete bxc[j];
            }
            delete exc;
        }

        void hdf5_read()
        {
            hdf5_tree fout("sirius.h5", false);
            effective_potential_->hdf5_read(fout["effective_potential"]);
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                effective_magnetic_field_[j]->hdf5_read(fout["effective_magnetic_field"][j]);
        }

        //**void hdf5_write()
        //**{
        //**    if (Platform::mpi_rank() == 0)
        //**    {
        //**        hdf5_tree fout("sirius.h5", false);
        //**        effective_potential_->hdf5_write(fout.create_node("effective_potential"));
        //**        fout.create_node("effective_magnetic_field");
        //**        for (int j = 0; j < parameters_.num_mag_dims(); j++)
        //**            effective_magnetic_field_[j]->hdf5_write(fout["effective_magnetic_field"].create_node(j));
        //**    }
        //**}
        
        void set_spherical_potential()
        {
            for (int ic = 0; ic < parameters_.num_atom_symmetry_classes(); ic++)
            {
               int ia = parameters_.atom_symmetry_class(ic)->atom_id(0);
               int nmtp = parameters_.atom(ia)->num_mt_points();
               
               std::vector<double> veff(nmtp);
               
               for (int ir = 0; ir < nmtp; ir++) veff[ir] = y00 * effective_potential_->f_rlm(0, ir, ia);

               parameters_.atom_symmetry_class(ic)->set_spherical_potential(veff);
            }
        }

        void set_nonspherical_potential()
        {
            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                double* veff = &effective_potential_->f_rlm(0, 0, ia);
                
                double* beff[] = {NULL, NULL, NULL};
                for (int i = 0; i < parameters_.num_mag_dims(); i++)
                    beff[i] = &effective_magnetic_field_[i]->f_rlm(0, 0, ia);
                
                parameters_.atom(ia)->set_nonspherical_potential(veff, beff);
            }
        }

        PeriodicFunction<double>* effective_potential()
        {
            return effective_potential_;
        }

        PeriodicFunction<double>** effective_magnetic_field()
        {
            return effective_magnetic_field_;
        }
        
        PeriodicFunction<double>* effective_magnetic_field(int i)
        {
            return effective_magnetic_field_[i];
        }

        template <processing_unit_t pu> 
        void add_mt_contribution_to_pw();

        /// Generate plane-wave coefficients of the potential in the interstitial region
        void generate_pw_coefs();
};

template<> void Potential::add_mt_contribution_to_pw<cpu>()
{
    Timer t("sirius::Potential::add_mt_contribution_to_pw");

    mdarray<complex16, 1> fpw(parameters_.num_gvec());
    fpw.zero();

    mdarray<Spline<double>*, 2> svlm(parameters_.lmmax_pot(), parameters_.num_atoms());
    for (int ia = 0; ia < parameters_.num_atoms(); ia++)
    {
        for (int lm = 0; lm < parameters_.lmmax_pot(); lm++)
        {
            svlm(lm, ia) = new Spline<double>(parameters_.atom(ia)->num_mt_points(), 
                                              parameters_.atom(ia)->type()->radial_grid());
            
            for (int ir = 0; ir < parameters_.atom(ia)->num_mt_points(); ir++)
                (*svlm(lm, ia))[ir] = effective_potential_->f_rlm(lm, ir, ia);
            
            svlm(lm, ia)->interpolate();
        }
    }
   
    #pragma omp parallel default(shared)
    {
        mdarray<double, 1> vjlm(parameters_.lmmax_pot());

        sbessel_pw<double> jl(parameters_, parameters_.lmax_pot());
        
        #pragma omp for
        for (int igloc = 0; igloc < parameters_.spl_num_gvec().local_size(); igloc++)
        {
            int ig = parameters_.spl_num_gvec(igloc);

            jl.interpolate(parameters_.gvec_len(ig));

            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                int iat = parameters_.atom_type_index_by_id(parameters_.atom(ia)->type_id());

                for (int lm = 0; lm < parameters_.lmmax_pot(); lm++)
                {
                    int l = l_by_lm_(lm);
                    vjlm(lm) = Spline<double>::integrate(jl(l, iat), svlm(lm, ia));
                }

                complex16 zt(0, 0);
                for (int l = 0; l <= parameters_.lmax_pot(); l++)
                {
                    for (int m = -l; m <= l; m++)
                    {
                        if (m == 0)
                        {
                            zt += conj(zil_[l]) * parameters_.gvec_ylm(Utils::lm_by_l_m(l, m), igloc) * 
                                  vjlm(Utils::lm_by_l_m(l, m));

                        }
                        else
                        {
                            zt += conj(zil_[l]) * parameters_.gvec_ylm(Utils::lm_by_l_m(l, m), igloc) * 
                                  (SHT::ylm_dot_rlm(l, m, m) * vjlm(Utils::lm_by_l_m(l, m)) + 
                                   SHT::ylm_dot_rlm(l, m, -m) * vjlm(Utils::lm_by_l_m(l, -m)));
                        }
                    }
                }
                fpw(ig) += zt * fourpi * conj(parameters_.gvec_phase_factor<local>(igloc, ia)) / parameters_.omega();
            }
        }
    }
    Platform::allreduce(fpw.get_ptr(), (int)fpw.size());
    for (int ig = 0; ig < parameters_.num_gvec(); ig++) effective_potential_->f_pw(ig) += fpw(ig);
    
    for (int ia = 0; ia < parameters_.num_atoms(); ia++)
    {
        for (int lm = 0; lm < parameters_.lmmax_pot(); lm++) delete svlm(lm, ia);
    }
}

#ifdef _GPU_
template <> void Potential::add_mt_contribution_to_pw<gpu>()
{
    Timer t("sirius::Potential::add_mt_contribution_to_pw");

    mdarray<complex16, 1> fpw(parameters_.num_gvec());
    fpw.zero();

    mdarray<double, 3> vlm_coefs(parameters_.max_num_mt_points() * 4, parameters_.lmmax_pot(), 
                                 parameters_.num_atoms());
    for (int ia = 0; ia < parameters_.num_atoms(); ia++)
    {
        for (int lm = 0; lm < parameters_.lmmax_pot(); lm++)
        {
            Spline<double> s(parameters_.atom(ia)->num_mt_points(), 
                             parameters_.atom(ia)->type()->radial_grid());
            
            for (int ir = 0; ir < parameters_.atom(ia)->num_mt_points(); ir++)
                s[ir] = effective_potential_->f_rlm(lm, ir, ia);
            
            s.interpolate();
            s.get_coefs(&vlm_coefs(0, lm, ia), parameters_.max_num_mt_points());
        }
    }
    vlm_coefs.allocate_on_device();
    vlm_coefs.copy_to_device();

    mdarray<int, 1> iat_by_ia(parameters_.num_atoms());
    mdarray<int, 1> nmtp_by_ia(parameters_.num_atoms());
    for (int ia = 0; ia < parameters_.num_atoms(); ia++)
    {
        iat_by_ia(ia) = parameters_.atom_type_index_by_id(parameters_.atom(ia)->type_id());
        nmtp_by_ia(ia) = parameters_.atom(ia)->num_mt_points();
    }
    iat_by_ia.allocate_on_device();
    iat_by_ia.copy_to_device();
    nmtp_by_ia.allocate_on_device();
    nmtp_by_ia.copy_to_device();

    l_by_lm_.allocate_on_device();
    l_by_lm_.copy_to_device();
    
    mdarray<double, 2> r_dr(parameters_.max_num_mt_points() * 2, parameters_.num_atom_types());
    for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
        parameters_.atom_type(iat)->radial_grid().get_r_dr(&r_dr(0, iat), parameters_.max_num_mt_points());
    r_dr.allocate_on_device();
    r_dr.copy_to_device();

    sbessel_pw<double> jl(parameters_, parameters_.lmax_pot());

    cuda_create_streams(Platform::num_threads());
    #pragma omp parallel
    {
        int thread_id = Platform::thread_id();

        mdarray<double, 3> jl_coefs(parameters_.max_num_mt_points() * 4, parameters_.lmax_pot() + 1, 
                                    parameters_.num_atom_types());
        
        mdarray<double, 2> vjlm(parameters_.lmmax_pot(), parameters_.num_atoms());

        vjlm.pin_memory();
        vjlm.allocate_on_device();
            
        jl_coefs.pin_memory();
        jl_coefs.allocate_on_device();

        #pragma omp for
        for (int igloc = 0; igloc < parameters_.spl_num_gvec().local_size(); igloc++)
        {
            int ig = parameters_.spl_num_gvec(igloc);
            
            jl.interpolate(parameters_.gvec_len(ig));
            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
            {
                for (int l = 0; l <= parameters_.lmax_pot(); l++)
                    jl(l, iat)->get_coefs(&jl_coefs(0, l, iat), parameters_.max_num_mt_points());
            }
            jl_coefs.async_copy_to_device(thread_id);

            bessel_vlm_inner_product_gpu(parameters_.max_num_mt_points(), parameters_.lmax_pot(), parameters_.lmmax_pot(), 
                                         parameters_.num_atoms(), parameters_.num_atom_types(), iat_by_ia.get_ptr_device(), 
                                         nmtp_by_ia.get_ptr_device(), l_by_lm_.get_ptr_device(), r_dr.get_ptr_device(), 
                                         jl_coefs.get_ptr_device(), vlm_coefs.get_ptr_device(), vjlm.get_ptr_device(), thread_id);

            vjlm.async_copy_to_host(thread_id);
            cuda_stream_synchronize(thread_id);

            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                complex16 zt(0, 0);
                for (int l = 0; l <= parameters_.lmax_pot(); l++)
                {
                    for (int m = -l; m <= l; m++)
                    {
                        if (m == 0)
                        {
                            zt += conj(zil_[l]) * parameters_.gvec_ylm(Utils::lm_by_l_m(l, m), igloc) * 
                                  vjlm(Utils::lm_by_l_m(l, m), ia);

                        }
                        else
                        {
                            zt += conj(zil_[l]) * parameters_.gvec_ylm(Utils::lm_by_l_m(l, m), igloc) * 
                                  (SHT::ylm_dot_rlm(l, m, m) * vjlm(Utils::lm_by_l_m(l, m), ia) + 
                                   SHT::ylm_dot_rlm(l, m, -m) * vjlm(Utils::lm_by_l_m(l, -m), ia));
                        }
                    }
                }
                fpw(ig) += zt * fourpi * conj(parameters_.gvec_phase_factor<local>(igloc, ia)) / parameters_.omega();
            }
        }
    }
    cuda_destroy_streams(Platform::num_threads());
    
    Platform::allreduce(fpw.get_ptr(), (int)fpw.size());
    for (int ig = 0; ig < parameters_.num_gvec(); ig++) effective_potential_->f_pw(ig) += fpw(ig);

    l_by_lm_.deallocate_on_device();
}
#endif

void Potential::generate_pw_coefs()
{
    for (int ir = 0; ir < parameters_.fft().size(); ir++)
        effective_potential()->f_it(ir) *= parameters_.step_function(ir);
    
    parameters_.fft().input(effective_potential()->f_it());
    parameters_.fft().transform(-1);
    parameters_.fft().output(parameters_.num_gvec(), parameters_.fft_index(), effective_potential()->f_pw());
    
    if (basis_type == pwlo) 
    {
        switch (parameters_.processing_unit())
        {
            case cpu:
            {
                add_mt_contribution_to_pw<cpu>();
                break;
            }
            #ifdef _GPU_
            case gpu:
            {
                add_mt_contribution_to_pw<gpu>();
                break;
            }
            #endif
            default:
            {
                error(__FILE__, __LINE__, "wrong processing unit");
            }
        }
    }
}

};


